\section{Preliminaries}\label{sec:preliminaries}

We start by providing the foundational definitions necessary for understanding the rest of the paper.

\begin{definition}[Alphabet, words, and languages]
\mbox{}\\[-0.5em]
\begin{itemize}
    \item An \emph{alphabet} $\Sigma$ is a finite nonempty set of symbols.
    \item A \emph{word} over $\Sigma$ is a finite sequence of symbols from $\Sigma$.
    \item The \emph{empty word} is denoted by $\varepsilon$.
    \item The \emph{set of all words} over $\Sigma$ is $\Sigma^*$.
    \item A \emph{language} over $\Sigma$ is a subset $\mathcal{L} \subseteq \Sigma^*$.
\end{itemize}
\end{definition}

\begin{definition}
Regular expressions over an alphabet $\Sigma$ are formally defined by the following grammar:

$$
r ::= \emptyset \mid \varepsilon \mid a\,(a \in \Sigma) \mid r+r \mid r\cdot r \mid r^* \mid r \& r \mid \neg r
$$
where $r$ ranges over regular expressions and $a$ ranges over symbols in $\Sigma$.
The intuitive meanings of these expressions are:
\begin{itemize}
    \item $\emptyset$ represents the empty language,
    \item $\varepsilon$ represents the language containing only the empty word,
    \item $a$ (for $a \in \Sigma$) represents the language containing only the one-letter word $a$,
    \item $r + s$ represents the union of the languages represented by $r$ and $s$,
    \item $r \cdot s$ represents the concatenation of languages represented by $r$ and $s$,
    \item $r^*$ represents the Kleene star of the language represented by $r$,
    \item $r \& s$ represents the intersection of languages represented by $r$ and $s$,
    \item $\neg r$ represents the complement of the language represented by $r$.
\end{itemize}
\end{definition}


\begin{definition}[Semantic interpretation]

For a regular expression $r$ over $\Sigma$, its semantic interpretation is the
language $\mathcal{L}(r) \subseteq \Sigma^*$ defined inductively by:
\[
\begin{aligned}
\mathcal{L}(\emptyset)   &= \emptyset, \\
\mathcal{L}(\varepsilon) &= \{\varepsilon\}, \\
\mathcal{L}(a)           &= \{a\}, \quad a \in \Sigma, \\[0.5ex]
\mathcal{L}(r + s)       &= \mathcal{L}(r) \cup \mathcal{L}(s), \\
\mathcal{L}(r \cdot s)   &= \{uv \mid u \in \mathcal{L}(r),\ v \in \mathcal{L}(s)\}, \\
\mathcal{L}(r^*)         &= \bigcup_{n \geq 0} \mathcal{L}(r)^n,
   \quad \text{where } \mathcal{L}(r)^0 = \{\varepsilon\},\
   \mathcal{L}(r)^{n+1} = \mathcal{L}(r)^n \cdot \mathcal{L}(r), \\
\mathcal{L}(r \& s)      &= \mathcal{L}(r) \cap \mathcal{L}(s), \\
\mathcal{L}(\neg r)      &= \Sigma^* \setminus \mathcal{L}(r).
\end{aligned}
\]
\end{definition}

\begin{definition}[Nullable regular expressions]\label{def:nullable}
In many constructions involving regular expressions it is useful to know
whether the language described by a given expression contains the empty word
$\varepsilon$. A regular expression $r$ is called \emph{nullable} if
$\varepsilon \in \mathcal{L}(r)$.

We define the \emph{nullable} function $\nu$ by
\[
\nu(r) =
\begin{cases}
  \varepsilon & \text{if $r$ is nullable},\\
  \emptyset   & \text{otherwise}.
\end{cases}
\]

Equivalently, $\nu$ is characterized by the following equations:
\[
\begin{array}{c}
     \nu (\varepsilon)=\varepsilon  \\[1ex]
     \nu(a)=\emptyset \quad (a \in \Sigma) \\[1ex]
     \nu(\emptyset)=\emptyset \\[1ex]
     \nu(r\cdot s)=\nu(r)\: \& \: \nu(s) \\[1ex]
     \nu(r+s) = \nu(r) + \nu(s) \\[1ex]
     \nu(r^*) = \varepsilon \\[1ex]
     \nu(r\:\&\:s) = \nu(r) \: \& \: \nu(s) \\[1ex]
     \nu(\neg r)= 
     \begin{cases}
         \varepsilon & \text{if } \nu(r) = \emptyset, \\
         \emptyset   & \text{if } \nu(r) = \varepsilon.
     \end{cases}
\end{array}
\]
\end{definition}

\begin{definition}[Canonical form]\label{def:canonical-form}
 $[r]$ denotes the canonical (normalized) form
of the regular expression $r$.
If $[r] = [s]$ for regular expressions $r$ and $s$, then
\[
  \mathcal{L}(r) = \mathcal{L}(s).
\]
\end{definition}

\begin{definition}[Semantic equivalence]\label{def:semantic-equivalence}
For regular expressions $r,s$ over $\Sigma$, we write
\[
  r \equiv s \quad\Longleftrightarrow\quad \mathcal{L}(r)=\mathcal{L}(s).
\]
\end{definition}

\begin{definition}[Similarity ($\sim$)]\label{def:similarity}
We use a decidable \emph{similarity} relation $\sim$ on regular expressions,
generated by standard equational laws for $+$ (idempotence, commutativity, associativity),
and optionally extended with additional simplifying laws (e.g.\ $r+\emptyset\sim r$, $\neg\neg r\sim r$, etc.).
\end{definition}

\begin{definition}[Canonicalization]\label{def:canonize}
Let $\mathsf{nf}(\cdot)$ be a canonicalization function on regular expressions.
We define similarity by:
\[
  r \sim s \quad\Longleftrightarrow\quad \mathsf{nf}(r)=\mathsf{nf}(s),
\]
where $=$ is syntactic (structural) equality of normalized expressions.
We write $[r]$ as shorthand for $\mathsf{nf}(r)$.
\end{definition}

\begin{lemma}[Soundness of normalization]\label{lem:similarity-sound}
If $r \sim s$, then $\mathcal{L}(r)=\mathcal{L}(s)$, hence $r \equiv s$.
\end{lemma}

\begin{remark}\label{rem:similarity-cites}
We do not re-prove the correctness of $\sim$ or $\mathsf{nf}$ here; we rely on the
construction and proofs of Coquand--Siles~\cite{CoquandRegexEquality}, where $\sim$ is implemented by normalization
(\texttt{canonize}) using smart constructors enforcing the equational laws.
\end{remark}