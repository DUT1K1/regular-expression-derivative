\section{Derivative of Regular Expressions with Fuzzy Similarity Relation}
In this paper, we generalize this notion using fuzzy similarity. Suppose $\cR$ is a fuzzy similarity relation on $\Sigma$, and let $\cut$ be a cut value ($0 < \cut \le 1$). Then the \emph{$\cut$-fuzzy derivative} of $\mathcal{L}$ with respect to a symbol $a \in \Sigma$, denoted $D_a^\cut(\mathcal{L})$, is defined as the set of suffixes $w$ such that there exists $b \in \Sigma$ with $\cR(a,b) \ge \cut$ and $bw \in \mathcal{L}$. In this way, the derivative is taken with respect to all symbols $b$ sufficiently similar to $a$, with the leading $b$ removed.

\begin{definition}
$$
\partial_a^\cut(\mathcal{L}) = \{w \in \Sigma^* \mid \exists b \in \Sigma\ \text{such that}\ \cR(a,b) \ge \cut\ \text{and}\ bw \in \mathcal{L}\}.
$$
Alternatively:
$$
\partial_a^\cut(\mathcal{L}) = \{w \in \Sigma^* \mid \exists b \in \Sigma\ \text{such that}\ (a, b) \in \cR_\cut\ \text{and}\ bw \in \mathcal{L}\}
$$
\end{definition}

\noindent
Just as in the classical setting, the notion of a fuzzy derivative with respect to a single symbol can be extended to handle derivatives with respect to an entire word. The idea remains the same: process the word one symbol at a time from left to right, taking the fuzzy derivative with respect to the first symbol and then applying the fuzzy derivative again to the result for the remaining suffix. This recursive approach naturally generalizes the single-symbol fuzzy derivative to arbitrary words, as formalized below.


\begin{definition}
    The fuzzy derivative of a language $\mathcal{L} \subseteq \Sigma^*$ with respect to a word $u=a\cdot v \in \Sigma^*$ where $a \in \Sigma$ and $v \in \Sigma^*$ is defined to be:
    $$
    \partial^\cut_u(\mathcal{L}) = \partial^\cut_v(\partial^\cut_a(\mathcal{L}))
    $$
\end{definition}

\noindent
An important property of the classical derivative is that it preserves regularity. This ensures that repeated differentiation never produces a language outside the regular class, making the operation suitable for automata-based  algorithms. The same closure property holds in the fuzzy setting: even when derivatives are taken with respect to a cut-based similarity relation, the resulting language remains regular. The following theorem states this formally.


\begin{theorem}\label{the:language-fuzzy-derivative-regular}
    If $\mathcal{L} \subseteq \Sigma^*$ is regular, then 
    $\partial^\cut_u(\mathcal{L})$ is also regular for any word 
    $u \in \Sigma^*$ and for any cut value $\cut \in [0,1]$.
\end{theorem}

\noindent
In order to compute fuzzy derivatives in practice, it is convenient to identify, for a given symbol and cut value, the set of symbols that are considered similar enough to be treated as matches. We call this set the \emph{cut neighborhood} of the symbol, and define it formally as follows.


\begin{definition}\label{def:cut-neighborhood}
    $\text{For } a\in\Sigma \text{ and } \cut\in[0:1] \text{ we define cut neighborhood as}$
    $$
        \mathcal{S}^\cut_a = \{b \in\Sigma :  (a,b)\in\mathcal{R}_\cut\}
    $$
\end{definition}

\noindent
As in the classical case, we distinguish between the \emph{semantic} fuzzy derivative, defined directly on languages, and the \emph{syntactic} fuzzy derivative, defined on regular expressions. The syntactic formulation allows us to compute derivatives by manipulating the structure of the expression itself, without first converting it to its 
language. In the fuzzy setting, this requires taking into account all symbols in the cut neighborhood of the given symbol. The following definition formalizes the syntactic fuzzy derivative.


\begin{definition}\label{def:regex-fuzzy-derivative}
    Let $R$ be a regular expression over the alphabet $\Sigma$, let
    $a \in \Sigma$ be a symbol and let $\cut\in[0:1]$.
    The \emph{fuzzy derivative of the regular expression $R$ with respect to $a$ and $\cut$}
    is the regular expression
    $$
        \mathcal{D}^\cut_{a}(R)
    $$
    whose language satisfies
    $$
        \mathcal{L}\bigl(\mathcal{D}^\cut_a(R)\bigr) = \{v \in \Sigma^* : \exists b\in 
            \mathcal{S}^\cut_a \land b\cdot v \in \mathcal{L}(R)
        \}
    $$
\end{definition}

\noindent We define fuzzy derivative for regular expressions
$$
\begin{array}{c}
    \mathcal{D}^\cut_a(\varepsilon)=\emptyset \\[1ex]
    \mathcal{D}^\cut_a(a)=\varepsilon \\[1ex]
    \mathcal{D}^\cut_a(b)=\emptyset \text{ for } b \notin \mathcal{S}^\cut_a \\[1ex]
    \mathcal{D}^\cut_a(\emptyset)=\emptyset \\[1ex]
    \mathcal{D}^\cut_a(r\cdot s)= \mathcal{D}^\cut_a(r)\cdot s + \nu(r)\cdot \mathcal{D}^\cut_a(s) \\[1ex]
    \mathcal{D}^\cut_a(r^*)=\mathcal{D}^\cut_a(r)\cdot r^* \\[1ex]
    \mathcal{D}^\cut_a(r+s)=\mathcal{D}^\cut_a(r)+\mathcal{D}^\cut_a(s) \\[1ex]
    \mathcal{D}^\cut_a(r\:\&\:s)=\mathcal{D}^\cut_a(r)\:\&\:\mathcal{D}^\cut_a(s) \\[1ex]
    \mathcal{D}^\cut_a(\neg r) = \neg(\mathcal{D}^\cut_a(r))
\end{array}
$$

\noindent
The semantic and syntactic definitions of the fuzzy derivative are intended to capture the same intuitive operation: removing a given prefix (up to similarity) from all words in the language. To confirm this alignment, we state the following correspondence theorem, which ensures that taking the fuzzy derivative at the syntactic level and then interpreting it as a language yields exactly the same result as first interpreting the expression and then applying the semantic fuzzy derivative.


\begin{theorem}[Semantic-syntactic correspondence]\label{the:two-fuzzy-derivative-mapping}
    Let $R$ be a regular expression over $\Sigma$, $u\in\Sigma^*$ and $\cut\in[0:1]$. Then
    $$
        \mathcal{L}\bigr(\mathcal{D}^\cut_u(R)\bigl)=\partial^\cut_u\bigr(\mathcal{L}(R)\bigl)
    $$
\end{theorem}

\subsection*{Examples}
Assume the alphabet $\Sigma = \{a, b, c\}$ and a fuzzy similarity relation $\cR$ on $\Sigma$ defined as follows:
\[
\begin{array}{c|ccc}
\cR & a & b & c \\
\hline
a & 1 & 0.8 & 0.4 \\
b & 0.8 & 1 & 0.5 \\
c & 0.4 & 0.5 & 1 \\
\end{array}
\]
Let the cut value be $\cut = 0.7$, so the $\cut$-cut of $\cR$ includes the pairs:
\[
\cR_\cut = \{(a, a), (a, b), (b, a), (b, b), (c, c)\}
\]
We can also observe that:
\[
\begin{array}{c}
     \mathcal{S}_a^\cut=\{a, b\} \\ [1ex]
     \mathcal{S}_b^\cut=\{a, b\} \\ [1ex]
     \mathcal{S}_a^\cut=\{c\}
\end{array}
\]
\noindent
Let $\mathcal{L} = \{abc, ba, bb\}$. Then:
\begin{itemize}
    \item $\partial_a^\cut(\mathcal{L}) = \{bc, a, b\}$\\
    Because:
    \begin{itemize}
        \item $(a,a) \in \cR_\cut$ and $abc \in \mathcal{L}$ $\Rightarrow$ $bc \in \partial_a^\cut(\mathcal{L})$
        \item $(a,b) \in \cR_\cut$ and $ba \in \mathcal{L}$ $\Rightarrow$ $a \in \partial_a^\cut(\mathcal{L})$
        \item $(a,b) \in \cR_\cut$ and $bb \in \mathcal{L}$ $\Rightarrow$ $b \in \partial_a^\cut(\mathcal{L})$
    \end{itemize}

    \item $\partial_c^\cut(\mathcal{L}) = \emptyset$\\
    Because:
    \begin{itemize}
        \item Only $(c,c) \in \cR_\cut$ with $\cR(c,c) = 1 \ge \cut$
        \item But $cb, ca, cc \notin \mathcal{L}$ $\Rightarrow$ no valid $bw$ with $(c,b) \in \cR_\cut$ and $bw \in \mathcal{L}$
    \end{itemize}

    \item $\partial_b^\cut(\mathcal{L}) = \{bc, a, b\}$\\
    Because:
    \begin{itemize}
        \item $(b,a) \in \cR_\cut$ and $abc \in \mathcal{L}$ $\Rightarrow$ $bc \in \partial_b^\cut(\mathcal{L})$
        \item $(b,b) \in \cR_\cut$ and $ba \in \mathcal{L}$ $\Rightarrow$ $a \in \partial_b^\cut(\mathcal{L})$
        \item $(b,b) \in \cR_\cut$ and $bb \in \mathcal{L}$ $\Rightarrow$ $b \in \partial_b^\cut(\mathcal{L})$
    \end{itemize}
\end{itemize}